<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F07%2F25%2F%E7%A8%BB%E9%A6%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[我在深圳的最后一天]]></title>
    <url>%2F2020%2F05%2F20%2F%E6%B7%B1%E5%9C%B3%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[今天是一个特殊的日子，并不是因为它是520，而是我在深圳五年的生活即将划上句号，晚上的火车就会带我回到熟悉家乡… 现在的心情很开心又很复杂~带着遗憾和成长离开了这个城市啦~ 加油~]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接下来是一个新的开始]]></title>
    <url>%2F2020%2F04%2F02%2F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[马上就可以换一个环境，回到自己喜欢的城市，离家近，不用再逢年过节再去抢票，安逸的生活下去。 那些过去的事情就让它过去吧，我已经准备好了，准备好了迎接接下来的一切。 锻炼身体 巩固技能 积极生活 努力的去迎接未来 加油~]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《请回答1988》]]></title>
    <url>%2F2020%2F03%2F02%2F%E3%80%8A%E8%AF%B7%E5%9B%9E%E7%AD%941988%E3%80%8B%2F</url>
    <content type="text"><![CDATA[《请回答1988》一部让人无法自拔的韩剧。 亲情 善英啊，天气这么冷，我们以后要不一起过吧 爱情 我赌上了1%的几率，希望那个人是你———宝拉和善宇 因为我要的我自己知道，只要你的肩膀愿让我靠———德善和阿泽 友情 王子贤，王祖贤；张美玉，张曼玉]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-equlas、hashCode理解]]></title>
    <url>%2F2019%2F02%2F19%2FJava-equlas%E3%80%81hashCode%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java基础复习。 12public boolean equals(Object obj)public int hashCode() 上述两个非常重要的方法来自每一个类的父类Object equals(Object obj)equals()方法在object类中定义如下： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 是比较引用是否相同。 大多数基本对象(String,Math)等都会复写equals()方法 比如在String类中如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n– != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false; &#125; String类复写equals方法其目的是为了比较内容,而不再是地址的比较。 很明显对象可以根据需要制定比较规则。 需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。 hashCode()hashCode()方法给对象返回一个hash code值。这个方法被用于集合里面比较. hashCode()方法在object类中定义如下： 1public native int hashCode(); 说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法 Java对于eqauls方法和hashCode方法是这样规定的 如果两个对象相同，那么它们的hashCode值一定要相同； 如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。 equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 Demo通过重写equals方法以及hashCode方法指定当前对象是否相等规则. 12345678910class TestModel&#123; private final String name; private final String id; public TestModel(String name, String id) &#123; this.name = name; this.id = id; &#125;&#125; 测试代码: 12345678ArrayList&lt;TestModel&gt; testModels = new ArrayList&lt;&gt;();testModels.add(new TestModel("hxw", "1"));boolean result = testModels.contains(new TestModel("hxw", "1"));System.out.print("result:"+result)输出:result:false 如上代码在集合中添加了一个TestModel对象,并且调用了集合的contains方法来判断当前集合中是否包含该对象,代码结果返回false,没有任何问题,那有没有办法让contains方法判断当前集合中包含改对象呢?(即contains方法返回true) 答案有的,Arraylist中contains方法代码如下: 12345678910111213141516public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; contains方法中调用了indexOf方法在集合中找位置,没找到返回-1,找到返回该对象在集合中的位置,indexOf就是通过调用对象的equals方法来判断在数组中是否有相同对象。 所以通过重写equals方法以及hashCode方法即可实现修改TestModel类代码如下: 12345678910111213141516171819202122232425262728class TestModel&#123; private final String name; private final String id; public TestModel(String name, String id) &#123; this.name = name; this.id = id; &#125; @Override public boolean equals(Object o) &#123; TestModel originModel = (TestModel) o; if (!name.equals(originModel.name)) &#123; return false; &#125; if (!id.equals(originModel.id)) &#123; return false; &#125; return true; &#125; @Override public int hashCode() &#123; return name.hashCode(); &#125; &#125; 修改后的TestModel重写了equals方法以及hashCode方法。hashCode返回name属性的hashCode,并且equals方法认定如果name以及id相同就认定为同一个对象。 12345678910 public static void main(String[] args) &#123; ArrayList&lt;TestModel&gt; testModels = new ArrayList&lt;&gt;(); testModels.add(new TestModel("hxw", "1")); boolean result = testModels.contains(new TestModel("hxw", "1")); log("result:" + result); &#125; 输出结果:result:true]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年不能落下的事情]]></title>
    <url>%2F2019%2F02%2F13%2F2019%E5%B9%B4%E4%B8%8D%E8%83%BD%E8%90%BD%E4%B8%8B%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[工作 Spring Boot + Mybatis 学习 JetPack包下控件的了解 Lifecycler * RxJava 操作符详细了解 Activity 启动流程 launcher相关 * JavaScript 学习启动篇（每两天一篇学习笔记） 基本语法 DOM * web开发 写个小项目 系统复习基础知识 Java equals、hashCode 内存模型 HashMap ArrayList 类加载器 JVM类加载流程 JVM垃圾回收 java对象生命周期 Synchronized原理 Volatile原理 ConcurrentHashmap Threadlocal原理 序列化前后对象有何区别 HashMap的原理 Java中的强、软、弱、虚引用 垃圾回收原理以及回收策略 双亲委派模型 什么是注解以及运行时注解的使用 同步锁 synchronized与Lock区别 Android 多进程 View绘制 触摸事件传递 LRUCache HTTPS 插件化开发流程 App的启动流程 View的性能优化，页面卡顿的原因 生活 坚持游泳 学会自由泳 周末练车 减少非必要开支 了解商业/医疗保险,父母年纪越来越大希望能对冲一些风险 多看看书 多自己做饭]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+uWSGI部署Django项目手记]]></title>
    <url>%2F2018%2F12%2F18%2FNginx%2BuWSGI%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE%E6%89%8B%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[折腾了两天的项目部署终于弄好了，记录一下。 部署环境 阿里云+ ubuntu 更新ubuntu默认2.x 至 python3.x sudo apt-get install python3.5 安装Django pip install django==xxx 安装uwsgi pip install uwsgi uwsgi –version # 查看 uwsgi 版本 安装nginx sudo apt-get install nginx uwsgi测试先直接run server 跑Django是否正常，如果正常则使用uwsgi运行项目 uwsgi –http :8000 –module xxx.wsgi xxx为项目名称 如果uwsgi运行正常，则外网能够访问项目 nginx 测试配置default.conf文件,安装成功后默认会在/etc/nginx/site-enabled/default 12345678910111213141516error_log logs/error.log;access_log logs/access.log;server &#123; # the port your site will be served on listen 80; # the domain name it will serve for charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste server_name 47.106.223.246; location / &#123; include /etc/nginx/uwsgi_params; &#125;&#125; 客户端直接输入IP地址应该会看房welcome nginx界面如果nginx启动成功。 nginx+uwsgi关联如果nginx能否访问成功，uwsgi也能够拉起Django项目最后一步将其关联即可。 项目目录下新建site.ini文件 123456789101112131415[uwsgi]chdir = /home/hxw_site/wsgi-file = hxw_site/wsgi.pymaster = truevhost = trueno-site = trueworkers = 2reload-mercy = 10vacuum = truemax-requests = 9000limit-as = 512buffer-size = 30000pythonpath = /usr/local/lib/python3.5/dist-packagessocket = /home/hxw_site/uwsgi.sock # sock文件生成位置daemonize = /home/hxw_site/uwsgi.log #错误log 重新生效 uwsgi –ini site.ini nginx设置反向代理，修改nginx.conf文件123456789101112131415161718192021222324252627282930313233upstream django &#123; server unix:///home/hxw_site/uwsgi.sock; # for a file socket # server 127.0.0.1:8001; # for a web port socket (we'll use this first)&#125;error_log logs/error.log;access_log logs/access.log;# configuration of the serverserver &#123; # the port your site will be served on listen 80; # the domain name it will serve for charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste server_name 47.106.223.246;# Django media #location /media &#123; # alias /home/www-data/www/mysite_data/media; # your Django #project's media files - amend as required #&#125; #location /static &#123; # alias /home/www-data/www/mysite/static; # your Django #project's static files - amend as required #&#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /etc/nginx/uwsgi_params; # the uwsgi_params file you installed &#125; location /static &#123; alias /home/hxw_site/static; &#125;&#125; 坑！需要注意no internal routing support, rebuild with pcre support 1.卸载uwsgi pip uninstall uwsgi 注意此时卸载，pip会有缓存留在系统里 2.安装pcre支持库 pip install pcre pcre-devel pcre-static 3.继续安装uwsgi，不走pip缓存 pip install uwsgi -I –no-cache-dir 启动uwsgi，已经没有!!! no internal routing support, rebuild with pcre support !!!报错了 启动以后500，查看uwsgi.log 发现ImportError，no django model 在site.ini文件中添加pathonpath = (python路径) pythonpath = /usr/local/lib/python3.5/dist-packages 注意site.ini文件中的socket属性值 socket = /home/hxw_site/uwsgi.sock 表示了sock文件生成位置，必须跟nginx 设置方向代理的server unix:///home/hxw_site/uwsgi.sock; 一致。不然访问不了 注意查看nginx以及uwsgi的error日志 error_log logs/error.log;access_log logs/access.log;相对路径在/usr/share/nginx/logs/下查看，有可直接写绝对路径。 每次测试需要重新启动超麻烦，简单的部署脚本 12345678910111213import sysimport osdef main(): os.system('pkill -9 nginx') os.system('nginx -c /etc/nginx/nginx.conf') os.system('pkill -9 uwsgi') os.system('rm -rf uwsgi.log') os.system('uwsgi --ini site.ini')if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那个背影]]></title>
    <url>%2F2018%2F12%2F09%2F%E9%82%A3%E4%B8%AA%E8%83%8C%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[最近晚上很早就上床，准备睡觉，然而我并睡不着，我现在的状态基本晚上不到一点不会睡，促使我做这个早睡的决定的是因为我最近经常跟一个同学聊天，是个女生，在家工作，同学年纪轻轻却已进入养生状态，早睡早起，令我羡慕不已，在这一来一去的聊天中得知我作息很差，遂劝我早睡，我尝试了下，结果我打开电脑写下此标题。 背影四十个月前,我看着心中的背影成长。 一个人在这城市生活，那个背影给了我很大勇气。 曾经那么远的，如今这么近，我信，我信。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的大前端]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%BF%9B%E5%87%BB%E7%9A%84%E5%A4%A7%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[HTML HTML DOM HTML5 CSS js vue]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妥协是降低标准的开始]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%A6%A5%E5%8D%8F%E6%98%AF%E9%99%8D%E4%BD%8E%E6%A0%87%E5%87%86%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[工作可以做的更好，选择妥协，过得去就好，如果工作每天都在妥协，降低标准，选择过得去就行，慢慢的慢慢的……一定会……蔓延至其他方面。 So say No!]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-多任务下载lib]]></title>
    <url>%2F2018%2F09%2F07%2FAndroid%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E8%BD%BDlib%2F</url>
    <content type="text"><![CDATA[Github功能 任何一个界面检测进度 单个任务下载 多个任务下载 取消单个任务 取消全部任务 暂停所有任务 队列最大同时下载任务数,超过则进入等待队列 自动恢复上一次下载任务 TODO 输出lib流程图 重试机制 使用方法downloader 权限相关12&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 添加依赖根项目的build.gradle： 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125;&#125; $lastVersion = 1implementation 'com.xwdz:QuietDownloader:$lastVersion' 在AndroidManifest.xml 声明如下service 1&lt;service android:name="com.xwdz.download.core.DownloadService"/&gt; 配置1. 在您的Application处调用初始化代码: XDownloaderManager.getImpl().bindService(this); 2. 添加一些列配置 QuietConfig.getImpl() // 默认下载路径为[sdcard/Download/包名/xxx.apk] // 若没有自定义下载文件路径,则必须调用该init代码 .initDownloadFile(context) //debug模式 .setDebug(boolean isDebug) //下载文件路径 .setDownloadDir(File file) // 队列最大同时下载任务数,超过则进入等待队列 默认:3 .setMaxDownloadTasks(int) // 最大线程下载数 默认:3 .setMaxDownloadThreads(int) // 间隔毫秒 .setMinOperateInterval(long) // 打开界面自动恢复下载 .setRecoverDownloadWhenStart(false); QuietDownloadConfig还提供了一处全局处理网络的接口: public interface HandlerNetwork { /** * 处理网络状况接口 * @return true: 消费该事件终止运行下载任务 * false: 正常执行下载任务 */ boolean onHandlerNetworkStatus(); } QuietConfig.getImpl().setHandlerNetworkListener(new QuietDownloadConfig.HandlerNetwork() { @Override public boolean onHandlerNetworkStatus() { // 自己的逻辑判断，提示当前不在wifi情况dialog 等 return false; } }); 关于监听QuiteDownload 并没有采用传统listener方式，而是使用了观察者模式,如需要在某个界面监听下载进度 1234567891011121314151617181920212223private final DataUpdateWatcher mDataUpdateReceiver = new DataUpdateWatcher() &#123; @Override public void notifyUpdate(DownloadEntry entry) &#123; // calback mainUIThread // do something // 可根据 entry status来判断一些列状态 if(entry.status == DownloadEntry.pause || DownloadEntry.downloading ...) &#125;&#125;;// 省略若干代码@Overrideprotected void onResume() &#123; super.onResume(); mDownloader.addObserver(mDataUpdateReceiver);&#125;@Overrideprotected void onPause() &#123; super.onPause(); mDownloader.removeObserver(mDataUpdateReceiver);&#125; 关于DownloadEntry12345678910111213141516171819202122232425262728293031public class DownloadEntry implements Serializable &#123; public String id; public String name; public String url; public int currentLength; public int totalLength; // ... 省略代码 public DownloadEntry(String url) &#123; this.url = url; this.id = url; this.name = url.substring(url.lastIndexOf("/") + 1); &#125; &#125; // ... 省略代码 @Override public boolean equals(Object o) &#123; return o.hashCode() == this.hashCode(); &#125; @Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = PRIME * result + id.hashCode(); return result; &#125;&#125; 注意 DownloadEntry实体类重写其 equals 以及 hashCode 方法，使用其 id hashCode 来作为其标准 QuietDownloader内部使用DownloadEntry实体类进行关联 DownloadEntry的几种状态123public enum DownloadStatus &#123; IDLE, WAITING, CONNECTING, DOWNLOADING, PAUSED, CANCELLED, COMPLETED, ERROR&#125; 使用方法12345678910111213141516171819private QuietDownload mDownloader = QuietDownload.getImpl();private final DownloadEntry downloadEntry = new DownloadEntry("url"); ... 省略代码 // 常用API // 开始任务 mDownloader.startDownad(downloadEntry); // 暂停任务 mDownloader.pause(downloadEntry); //取消任务 mDownloader.cancel(downloadEntry); // 恢复任务 mDownloader.resume(downloadEntry); // 恢复所有 mDownloader.recoverAll(downloadEntry); // 暂停所有 mDownloader.pauseAll(downloadEntry);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通生活]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%99%AE%E9%80%9A%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[生活就是不断创造问题，解决问题再创造问题。 用在最近的自己身上在合适不过了。 真的真的很讨厌看那些为了应付而写的文档。 不多说了,听首歌压压惊]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星球坠落]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%98%9F%E7%90%83%E5%9D%A0%E8%90%BD%2F</url>
    <content type="text"><![CDATA[歌手：艾热 / 李佳隆 作曲：艾热 / 李佳隆 作词：艾热 / 李佳隆 好听。 对中国新说唱这个节目关注并不算高，不过总会流传出几首好听的曲目对我胃口，去年的time,今年的星球坠落。]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Where Is the Love]]></title>
    <url>%2F2018%2F08%2F08%2FWhere%20Is%20the%20Love%2F</url>
    <content type="text"><![CDATA[歌手：Josh Vietti]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平凡的生活]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%B9%B3%E5%87%A1%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[歌手：毛不易作曲：毛不易作词：毛不易 生活可以不那么复杂 就这样虚度着年华 没牵挂 只有晚风轻拂着脸颊 总有一天 我们会找到她]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Django]]></title>
    <url>%2F2018%2F07%2F18%2FPython-Django%2F</url>
    <content type="text"><![CDATA[Django官方文档 版本信息 python : 3.6 操作环境 : mac django : 2.0 需要安装 pip django mysql 安装Django pip install Django==2.0 可使用django-admi是否验证安装成功 123456789[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush ... 输出如上说明成功 创建一个项目 djando-admin startproject site(项目名称) 目录结构如下 123456+-- project -- __init__.py -- settings.py 配置各种组件 -- urls.py 配置每个页面url地址 -- wsgi.py python应用与web服务器交互+-- manage.py 管理器 启动server等 运行server进入manage.py同级目录执行命令 python manage.py runserver 8989(端口,可选,默认8080) 打开浏览器输出http://127.0.0.1:端口/ 回车没报错则说明运行成功 创建一个应用进入manage.py同级目录执行命令 python manage.py startapp blog(应用名称) 自动生成目录结构如下 123456789blog/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 接受请求以及返回代码编写 配置site/INSTALLED_APPS1234567'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog' # 应用名称 接收一个request请求打开 blog/views.py 123456from django.shortcuts import renderfrom django.http import HttpResponsedef login(request): return HttpResponse('hello Django!') 注意: 函数参数带了request的说明会有请求过来 配置urls.py在blog文件夹下创建urls.py文件 from django.urls import path from . import views as blog urlpatterns = [ path(&apos;login/&apos;, blog.login), ] 123456789101112131415# site/urls.py文件 from django.contrib import adminfrom django.urls import pathfrom django.urls import include urlpatterns = [ # 默认存在 path('admin/', admin.site.urls), # 自己配置 path('auth/', include('blog.urls')),] 执行 python manage.py runserver 3232 在浏览器打开即可看见hello Django! eg:一个urls.py配置列子 123456789101112131415path site(项目)/urls.py配置如下 path('auth',include('blog.urls'))) -- login http://127.0.0.1:9999/auth/login/ blog/urls.py 配置如下 path('login/', blog.login) -- getUserName http://127.0.0.1:9999/auth/getUserName/ path('getUserName/', blog.getUserName)list site(项目)/urls.py配置如下 path('list',include('blog.urls'))) -- getOrderlist http://127.0.0.1:9999/list/getOrderlist/ blog/urls.py 配置如下 path('getOrderlist/', blog.getOrderlist) API抛出json数据结构在blog/views.py 编写接口 1234567891011121314151617def getJsonTest: resultJson = &#123;&#125; result = &#123;'name': 'huang', 'age': '11'&#125; result2 = &#123;'name': 'huang', 'age': '11'&#125; result3 = &#123;'name': 'huang', 'age': '11'&#125; testJson = &#123; 'datetime': '昨天', 'starttime': "今天" &#125; result4 = &#123;'name': testJson, 'age': '11'&#125; listdata = [result, result2, result3, result4] resultJson['list'] = listdata resultJson['msg'] = 'this is message' print('request count ' + str(REQUESTCOUNT)) return HttpResponse(json.dumps(resultJson), content_type="application/json") 在Rresponse添加如下content_type=”application/json”返回即是json数据 配置数据库配置Site/settings.py下DATABASES模块 123456789101112131415DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'douban_info', # 你要存储数据的库名，事先要创建 'USER': 'root', # 数据库用户名 'PASSWORD': '123123', # 密码 'HOST': 'localhost', # 主机 'PORT': '3306', # 数据库使用的端口 &#125;# 默认使用sqlite3 #'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), #&#125;&#125; Django中的ORM新建class继承models.Model表明新建表 1234567class user(models.Model): name = models.TextField(max_length=332) desc = models.TextField(max_length=223) db = models.Manager() def __str__(self): return self.name 注意 安装mysql如果报错do you install mysqlclient ？ 在site/init.py 添加如下代码 12import pymysqlpymysql.install_as_MySQLdb() 执行命令 python manage.py makemigrations（可选） python manage.py migrate 数据库查询先导入model模块 12from blog import models as modelmodel.Test0.db.all().values().first() ...]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百家湖，我们的车窗升起了雾]]></title>
    <url>%2F2018%2F06%2F23%2F%E7%99%BE%E5%AE%B6%E6%B9%96%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84%E8%BD%A6%E7%AA%97%E5%8D%87%E8%B5%B7%E4%BA%86%E9%9B%BE%2F</url>
    <content type="text"><![CDATA[歌手：蚂蚁先生 作曲：蚂蚁 作词：蚂蚁]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的眼睛]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%BD%A0%E7%9A%84%E7%9C%BC%E7%9D%9B%2F</url>
    <content type="text"><![CDATA[歌手：陈小熊 作曲：陈洁修 作词：陈洁修 和软软的白云 在晨曦的歌声里 在沉醉的岁月里 在转瞬的生命里 多想和你 一起]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栖息]]></title>
    <url>%2F2018%2F06%2F20%2F%E6%A0%96%E6%81%AF%2F</url>
    <content type="text"><![CDATA[歌手：郭诚（橙子） 作曲：少年佩 作词：郭诚 行文泽 遥远星河漫天不言语， 越万籁俱寂越发让人清醒， 那日早已作别的故里， 匆匆的旅人是我也曾是你， 匆匆的旅人正在被谁惦记。]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下一站茶山刘]]></title>
    <url>%2F2018%2F06%2F19%2F%E4%B8%8B%E4%B8%80%E7%AB%99%E8%8C%B6%E5%B1%B1%E5%88%98%2F</url>
    <content type="text"><![CDATA[歌手：房东的猫 作曲 : 少年佩 作词 : 少年佩/红鼻子小黑/李纤橙 还没说完的话 就算了吧 总有些遗憾要学会放下 前路不需太重的行囊 和过去和解吧 我会像永远不变的时光 一如既往 哪怕从此离开了家乡]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[她说每个人心中都有一首歌]]></title>
    <url>%2F2018%2F06%2F13%2F%E5%A5%B9%E8%AF%B4%E6%AF%8F%E4%B8%AA%E4%BA%BA%E5%BF%83%E4%B8%AD%E9%83%BD%E6%9C%89%E4%B8%80%E9%A6%96%E6%AD%8C%2F</url>
    <content type="text"><![CDATA[歌手：陈小熊 作曲 : 陈洁修 作词 : 陈洁修 她说 每个人的心中都有一首歌, 那时爱的人 曾为你哼唱过 我说 岁月太匆忙 我们都不够深刻 你和我 都只是 过客 你和我 再唱起 那首歌]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[只道寻常]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%8F%AA%E9%81%93%E5%AF%BB%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[歌手：谢知非(谢春花) 作曲 : 谢知非 作词 : 谢知非 离别时只道是当时习惯一切都很平淡不觉出彩， 雨落时才想起那种心安欢声和笑语还在我耳畔， 如今已各自在城市两端相距远相见难不聚只散， 其实我并没有太多期盼毕竟一生很短少有圆满。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仪式感]]></title>
    <url>%2F2018%2F05%2F20%2F%E4%BB%AA%E5%BC%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[用日出而作，日落而息来形容今天不为过，满满的玩了一天，吃的好爽前一段时间锻炼感觉白干了，回到家很累，不过依然坚持做了自己明天饭菜。 在今天这个日子里，想起来奇葩说里面的一起辩论，中国人什么都喜欢讲究个仪式感，从古至今，皇帝登基，考状元，求婚，结婚。 生日今天我妈给我打了电话，但我的生日并不是今天，是前天，我从懂事后我基本就没过过生日了，以前的话我妈都会给我打电话问问我在干嘛，今年也许忙了吧忘了不过我也不在意过不过，电话打过来的时候我能感觉通话过程中她非常内疚，因为儿子生日的那天她没有给我打电话，这也许就是所谓的仪式感吧，让我又了一些思考，我说生日没什么的忘了就忘了呗，(内心其实还是想接到妈电话)不过我妈并不接受，心里面应该比较内疚，有时间想想生活中有很多形式主义并不是那么的不好，但总比懒的连过场都懒的走。仪式感让我清楚的知道自己在做什么，为了什么，仪式感是一种生活的意义，给我期待，给我心安。 晚安。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-App检测升级库]]></title>
    <url>%2F2018%2F05%2F10%2FAndroid-App%E6%A3%80%E6%B5%8B%E5%8D%87%E7%BA%A7%E5%BA%93%2F</url>
    <content type="text"><![CDATA[QuiteVersion用于Android App检测自动更新 添加依赖1234implementation 'com.xwdz:QuiteVersion:0.0.5'implementation 'com.xwdz:okHttpUtils:1.0.4'//如已依赖可忽略implementation 'com.squareup.okhttp3:okhttp:3.5.0' 实现效果 特点 任何地方都可以调用 支持自定义界面 支持强制下载最新Apk 自调起安装界面 简单 支持OKHttp拦截器 适配7.0 简单使用12345678910111213141516171819202122232425262728293031 DialogTest dialogTest = DialogTest.newInstance(); Quite.getInstance(this) //or POST .GET("http://www.baidu.com") //强制每次更新都从网络下载最新Apk .setForceDownload(true) .setApkPath() .setApkName() .addHeader() .setShowUIActivity() .addParams() .addInterceptor() .addNetworkInterceptor() //UI容器需实现OnUINotify接口 .setNotifyHandler(dialogTest) .setOnNetworkParserListener(new OnNetworkParserListener() &#123; @Override public ApkSource parser(String response) &#123; return new ApkSource( kugou, "更新内容如下\n1.你好\n2.我不好", 123123123, 123, 9999 ); &#125; &#125;) .apply();//界面销毁时注意释放资源Quite.getInstance(this).recycle() 注意开发者必须实现此接口,返回QuiteVersion需要的Apk信息,如果返回null,则视为没有新版本更新123456setOnNetworkParserListener(new OnNetworkParserListener() &#123; @Override public ApkSource parser(String response) &#123; return null; &#125; &#125;) QuiteVersion 执行更新App策略- ApkSource.remoteVersionCode &gt; 当前版本code - todo setApkName以及setApkPath说明 QuiteVersion 默认实现路径为context.getExternalFilesDir(&quot;apk&quot;).getAbsolutePath() + File.separator + apkFilename **QuiteVersion 默认实现文件名称为Url最后一个/ 至 .apk,如酷狗 http://download.kugou.com/download/kugou_android` `ApkName为kugou_android.apk`** 自定义容器Dialog 继承AbstractActivity实现自己的UI,重写如下三个方法,通过setShowUIActivity(xxx.class)注入. 123456//自己定义的UI layoutpublic abstract int getContentLayoutId();//数据初始化public abstract void setUpData();//当执行下载任务的时候回回调到此方法public abstract void updateProgress(int percent, long currentLength, long total); 默认的ProgressDialogActivity也是基于此实现。可通过String note = getIntent().getStringExtra(&quot;note&quot;)拿到更新文本。 实现OnUINotify接口在不指定.setNotifyHandler()方法以及setShowUIActivity方法时默认实现效果参照文章开头在自定义容器中实现此接口,在接口方法show中调用真正的show方法,详见simple-code 注意:自定义容器只能使用一种方式。 自定义容器中，点击开始下载时,需要调用如下代码1VersionHandler.startDownloadApk(getContext()); 自定义容器中注册接受下载进度条组件12345678910111213private final VersionHandler.ProgressReceiver mProgressReceiver = new VersionHandler.ProgressReceiver() &#123; @Override public void onUpdateProgress(long total, long currentLength, int percent) &#123; Utils.LOG.i("tag", "current = " + currentLength); &#125; &#125;;//在容器创建等合适的时候调用注册代码VersionHandler.registerProgressbarReceiver(getContext(), mProgressReceiver);//容器销毁的时候调用注销代码VersionHandler.unregisterProgressbarReceiver(getContext(), mProgressReceiver); 适配7.0在AndroidManifest.xml添加如下代码 123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="您的包名.fileProvider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; 在res文件夹下新建xml文件夹新建文件file_paths.xml添加如下代码 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;external-path path="Android/data/您的包名/" name="files_root" /&gt; &lt;external-path path="." name="external_storage_root" /&gt;&lt;/paths&gt; @酸菜xwdzGithub]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Hook-一行代码实现开屏广告]]></title>
    <url>%2F2018%2F05%2F09%2FAndroid-Hook-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[需求背景多个产品线都需要实现开屏广告，我们产品广告都是接的我们自家广告SDK，而SplashActivity只是几行代码请求我们广告，广告SDK会把View封装好返回来，SplashActivity要做的事情只是获取响应结果，并且show出来. 如何实现一行代码实现开屏广告 通过Hook Instrumentation监听到App主界面启动并且回调出来，然后跳转到内置的一个activity里面实现开屏广告广告结束再finish。 如何鉴别是否是主LAUNCHER(App第一个启动界面) 关于如何判断APP的第一个启动界面请看AndroidManifest.xml一段代码1234567&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; intent-filter标签里面两个字段分别表示如下意思 android.intent.action.MAIN 决定应用程序最先启动的Activity android.intent.category.LAUNCHER表示activity应该被列入系统的启动器(launcher)(允许用户启动它)。Launcher是安卓系统中的桌面启动器，是桌面UI的统称。 也就是说根据如上标签可以判断是否是App第一个入口Activity代码如下: 123if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; intent.hasCategory(Intent.CATEGORY_LAUNCHER)) &#123;&#125; 如何Hook Instrumentation实现监听Activity生命周期我们在Activity调用的startActivity(intent)方法最后都会调用到Instrumentation的execStartActivity方法,而最后activity的创建会被回调到Instrumentation的callActivityOnCreate方法。强烈推荐Activity的启动过程 也就是说只需要我们通过反射替换Instrumentation然后在callActivityOnCreate方法里面回调出来即可。反射基础用法 代码如下: 实现Instrumentation实现一个代理类:123456789101112131415161718192021222324252627282930313233343536/** * @author 黄兴伟 (xwd9989@gamil.com) * @since 2018/5/9 */public class ProxyInstrumentation extends Instrumentation &#123; private OnActivityCreateListener mOnActivityCreateListener; public ProxyInstrumentation() &#123; Log.e("TAG", "ProxyInstrumentation created"); &#125; public void setActivityCreateListener(OnActivityCreateListener onActivityCreateListener) &#123; this.mOnActivityCreateListener = onActivityCreateListener; &#125; @Override public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; super.callActivityOnCreate(activity, icicle); final Intent intent = activity.getIntent(); if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; intent.hasCategory(Intent.CATEGORY_LAUNCHER)) &#123; //判断是否是住入口 回调 if (mOnActivityCreateListener != null) &#123; mOnActivityCreateListener.onHookActivityCreated(activity, icicle); &#125; &#125; &#125; /*回调接口*/ public interface OnActivityCreateListener &#123; void onHookActivityCreated(Activity activity, Bundle icicle); &#125;&#125; 反射获取Instrumentation,将代理ProxyInstrumentation注入到ActivityThread中代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author 黄兴伟 (xwd9989@gamil.com) * @since 2018/5/9 */public class HookActivityHelper &#123; private static final HookActivityHelper INSTANCE = new HookActivityHelper(); private ProxyInstrumentation mProxyInstrumentation; public static HookActivityHelper get() &#123; return INSTANCE; &#125; public void open() &#123; mProxyInstrumentation.setActivityCreateListener(new ProxyInstrumentation.OnActivityCreateListener() &#123; @Override public void onHookActivityCreated(Activity activity, Bundle icicle) &#123; Intent intent = new Intent(activity, WelcomeActivity.class); activity.startActivity(intent); &#125; &#125;); &#125; private HookActivityHelper() &#123; try &#123; Class&lt;?&gt; clazz = Class.forName("android.app.ActivityThread"); Method currentActivityThread = clazz.getDeclaredMethod("currentActivityThread"); Object object = currentActivityThread.invoke(null); Field field = clazz.getDeclaredField("mInstrumentation"); field.setAccessible(true); mProxyInstrumentation = new ProxyInstrumentation(); field.set(object, mProxyInstrumentation); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 新建内置WelcomeActivity1234567891011121314151617181920212223242526272829303132/** * 再这个内置的Activity实现开屏广告UI或请求广告SDK即可 * @author 黄兴伟 (xwd9989@gamil.com) * @since 2018/5/9 */public class WelcomeActivity extends AppCompatActivity &#123; private TextView mTextView; private CountDownTimer mCountDownTimer = new CountDownTimer(6000, 1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; mTextView.setText("Hook成功，欢迎来到酸菜个人站点 huangxingwei.cn 6秒后返回MainActivity = " + millisUntilFinished / 1000); &#125; @Override public void onFinish() &#123; finish(); Log.e("TAG", "WelcomeActivity finished"); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.e("TAG", "WelcomeActivity created success"); setContentView(R.layout.welcome_layout); mTextView = findViewById(R.id.text); mCountDownTimer.start(); &#125;&#125; AndroidManifest.xml声明如下123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xwdz.simple"&gt; &lt;application android:name=".TestApp" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".hook.WelcomeActivity"/&gt; &lt;/application&gt;&lt;/manifest&gt; 最后再程序的Application编写一行代码即可实现开屏广告。12345678public class TestApp extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); HookActivityHelper.get().open(); &#125;&#125; Log如下123405-09 17:27:40.832 3997-3997/? E/TAG: ProxyInstrumentation created05-09 17:27:40.853 3997-3997/? E/TAG: MainActivity created success05-09 17:27:41.072 3997-3997/? E/TAG: WelcomeActivity created success05-09 17:27:51.091 3997-3997/com.xwdz.simple E/TAG: WelcomeActivity finished 测试效果如下 总结完整代码参照simple-code，其实HookActivity还可以做更多的事，比如插件Activity等，希望能给大家提供到思路，感谢阅读。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后的唐寅]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9C%80%E5%90%8E%E7%9A%84%E5%94%90%E5%AF%85%2F</url>
    <content type="text"><![CDATA[初识刚温故了电影&lt;唐伯虎点秋香&gt;因为对他最初的印象是从这里产生的直接影响，唐伯虎能文能武，智斗奸臣，抱得美人归，十分搞笑。而如今明白真相之后再看电影，却再也笑不出来。 彻底堕落最后的才子唐伯虎利用装疯，裸奔等方法从朱宸濠(朱宸濠造反需要人才，故想收编唐伯虎，而唐一开始以为是要聘他为太师之类的,知道是造反后想溜，可知道了那么多秘密怎能放你走)虎口脱险松了一口气，但在庆祝劫后余生的同时，他对人生也已经彻底绝望。 日以继夜的饮酒作乐，纵情声色，摧垮了他的身体，却也成就了他的艺术。 但也就到此为止了，1523年这位中国文化历史上的天才结束了自己坎坷的一声归于沉寂。 再看电影时，在我脑海里始终浮现的是那个真实的唐伯虎，在无奈中痛苦挣扎，无比绝望，中年怀才不遇，老年心灰意冷，不禁让人心疼。 桃花歌别人笑我太疯癫， 我笑他人看不穿。 不见五陵豪杰墓， 无花无酒锄作田。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假期之后]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%81%87%E6%9C%9F%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[明天上最后一天班又是周末，舒服！ 开始做饭节后上班到现在每天晚上都做饭带饭，说来已经三天了，本想着会很累，毕竟每天下班到家已经9点多了，可还是坚持自己做了两个菜，不为别的，节前的时候点了个三级第，吃完肚子疼跑了无数次厕所，唉，这次的遭遇也让我彻底的反感外卖，上班到现在以前都是叫外卖，周末从来都是外卖，我这不知道吃了几年地沟油了… 趁着五一的时候放假，去超市买了一百多块钱的菜，想着应该能吃很久了吧，刚开始做得时候由于厨艺生疏，在饭菜质量把控上面，也着实让自己捏了一把汗， 因为我总是炒糊… 做饭上瘾 刚刚炒的菜，是我目前炒的卖相最好的，颜色分明，不像之前炒的大部分都是黑色的，因为有很多地方是糊的… 是因为我没有翻炒而火又比较大直接给糊了。明天有口福了 我为何要表明主题是做饭上瘾呢，是因为我让我自己上瘾的，严格来说是即使自己不想做饭，也逼着自己做，让其成为一种习惯，习惯是不会累的，习惯让自己过得更舒服。 习惯最近我也在恶补英语，自然不会少了背单词这个大工程，当看代码看到注释或者其他地方有不认识的单词，恨一波单词用时方很少啊，便给自己定了计划。 常用单词7500个，每天背30个，那么需要250天把这些单词背完，这其中肯定也会有自己认识的严格来讲不会需要250天。 我是怎么背的一张草稿纸，笔，然后每个单词写上听上个10来遍，如此反复。 这种方式对我来说不错，只需长期坚持。 杂谈最近迷上了本书&lt;明朝那些事&gt;共七册，不得不说作者写的很棒，脉络清楚，虽说是历史，文字却也幽默。以前觉得皇帝陛下很享受，万人之上，后宫佳丽三千，然而皇帝却是一个高危职业，皇帝身边的人更加危险。 对外:来说一旦国家危在旦夕，皇帝怎能苟且，唯有一死 对内:皇帝最难得就是朋友,因为无时无刻都得提防着身边的人，也许哪天醒来已然成为阶下囚。这也是为啥皇帝总是说孤家寡人 心狠在我看来是皇帝的第一要素，朱元璋创业成功以后杀掉自己以前一起打天下的战友，功高盖主可不行，即使你没有，也得杀，保不齐将来对自己产生威胁，正如书里说的，朱元璋要么不做，要么做绝。 最后ps:本来想分享一下~不过没有版权并不能播放 晚安]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 观察者模式]]></title>
    <url>%2F2018%2F05%2F01%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式定义对象的一种一对多的依赖关系，使得每当一个改变状态，则所有依赖它的对象都会得到通知并更新 比如之前自己项目，有一个后台下载任务，下载进度要在任何activity都可以收到，此时一对多的观察者模式最好不过了。 Java JDK已经实现了一套观察者模式 根据思路可建如下两个类 DownLoadState 观察者，观察数据源是否改变 DownloadObservable 被观察者，数据源发生改变 Entry 实体类 实体类如下: 12345public class Entry &#123; public String id; public String currentLength;&#125; 定义观察者如下: 12345678910111213141516public abstract class DownLoadState implements Observer &#123; public DownLoadState() &#123; &#125; @Override public void update(Observable observable, Object o) &#123; if (o instanceof Entry) &#123; Entry entry = (Entry) o; updateUi(entry); &#125; &#125; public abstract void updateUi(Entry entry);&#125; 被观察者: 1234567891011121314151617181920212223242526272829public class DownloadObservable extends Observable &#123; private static final DownloadObservable CODER_OBSERVABLE = new DownloadObservable(); public static CoderObservable get() &#123; return CODER_OBSERVABLE; &#125; private CoderObservable() &#123; &#125; public void addDownloadState(DownLoadState downLoadState) &#123; addObserver(downLoadState); &#125; public void removeDownloadState(DownLoadState downLoadState) &#123; deleteObserver(downLoadState); &#125; public void post(String msg) &#123; setChanged(); notifyObservers(msg); &#125;&#125; 测试代码如下: 123456789101112131415161718192021222324252627282930public static void main(String args[])&#123; DownLoadState downLoadState = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownLoadState downLoadState1 = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownLoadState downLoadState2 = new DownLoadState() &#123; @Override public void updateUi(Entry entry) &#123; System.out.println("当前任务ID = " + entry.id + " 接受到更新 = " + entry.currentLength); &#125; &#125;; DownloadObservable.get().addDownloadState(downLoadState); DownloadObservable.get().addDownloadState(downLoadState1); DownloadObservable.get().addDownloadState(downLoadState2); Entry entry = new Entry(); entry.id = "1"; for (int i = 0; i &lt; 100; i++) &#123; entry.currentLength = String.valueOf(i); CoderObservable.get().post(entry); &#125;&#125; 输出如下： 1234567891011观察者downLoadState2 当前任务ID = 1 接受到更新 = 0观察者downLoadState1 当前任务ID = 1 接受到更新 = 0观察者downLoadState 当前任务ID = 1 接受到更新 = 0观察者downLoadState2 当前任务ID = 1 接受到更新 = 1观察者downLoadState1 当前任务ID = 1 接受到更新 = 1观察者downLoadState 当前任务ID = 1 接受到更新 = 1...观察者downLoadState2 当前任务ID = 1 接受到更新 = 99观察者downLoadState1 当前任务ID = 1 接受到更新 = 99观察者downLoadState 当前任务ID = 1 接受到更新 = 99 总结如上需求，则只需要在需要接受到下载进度条的activity创建的时候调用DownloadObservable.get().addDownloadState方法即可接受，在activity销毁的时候调用DownloadObservable.get().removeDownloadState方法避免内存泄漏问题。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Hook基础-动态代理]]></title>
    <url>%2F2018%2F04%2F28%2FAndroid-Hook%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理顾名思义，委托别人来帮助自己完成一些事情。例如打官司是不是要请律师，这样的一种关系就可以叫做代理关系。 静态代理 小明姨妈本想明天约小明妈妈去超市超市大甩卖，不过小姨妈临时需要去学习办点事去，这时小明姨妈委托小明告诉小明妈妈，明天某某超市大甩卖，让小明妈妈明天再门口等小明姨妈一起去超市购物。不过小明不仅告诉了自己妈妈，还告诉了一个不认识的大妈 如此小明便成为一个代理者。 1234public interface SendMessage &#123; void sendMsg(String msg);&#125; 实现类如下 1234567public class SendMessageImpl implements SendMessage &#123; @Override public void sendMsg(String msg) &#123; System.out.println(msg); &#125;&#125; 代理类 1234567891011121314151617181920212223public class ProxySend implements SendMessage &#123; SendMessage mSendMessage; public ProxySend(SendMessage sendMessage) &#123; mSendMessage = sendMessage; &#125; @Override public void sendMsg(String msg) &#123; System.out.println("大妈，隔壁某某超市甩卖了拉，赶紧去买点便宜的东西"); mSendMessage.sendMsg(msg); &#125;&#125;public statis void main(String[] args)&#123; final SendMessage sendMessage = new SendMessageImpl(); ProxySend send = new ProxySend(sendMessage); send.sendMsg("超市大甩卖");&#125; 123输出结果:大妈，隔壁某某超市甩卖了拉，赶紧去买点便宜的东西超市大甩卖 由于静态代理需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？ 使用动态代理则不需要手写每一个静态代理类。 12345678SendMessage proxy = (SendMessage) Proxy.newProxyInstance(sendMessage.getClass().getClassLoader(), sendMessage.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; return method.invoke(sendMessage,objects); &#125; &#125;); proxy.sendMsg("代理类发出信息 超市大甩卖"); 动态代理主要处理InvocationHandler和Proxy类，在InvocationHandler反射调用方法。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Hook基础-反射]]></title>
    <url>%2F2018%2F04%2F27%2FAndroid-Hook%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Hook基础-反射通过Class.forName静态方法可以根据类的绝对路径拿到某个类的Class实例 新建测试Test类如下package com.example.lib; public class Test { private String username; private String password; public Test(){ } public int showInfo(String name,String pwd){ MyClass.print(&quot;name = &quot; + name); MyClass.print(&quot;pwd = &quot; + pwd); return 2; } @Override public String toString() { return &quot;Test{&quot; + &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &apos;}&apos;; } } 反射变量public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Field username = cls.getDeclaredField(&quot;username&quot;); username.setAccessible(true); username.set(object,&quot;100&quot;); } 输出 Test{username=&apos;100&apos;, password=&apos;null&apos;} 注意 set(Object var1, Object var2) 方法接收两个参数 var1 : 当前实例var2 : 修改的实例 get(Object var1) 方法接受一个参数 var1 : Field实例 如果没加username.setAccessible(true)则会报错如下 can not access a member of class x.com.lib.Test with modifiers “private” 因为Test里面定义的变量是private的,改成public即可。 如果需要获取到private属性的则需要加username.setAccessible(true)。 public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Field username = cls.getDeclaredField(&quot;username&quot;); username.setAccessible(true); username.set(object,&quot;100&quot;); Field password = cls.getDeclaredField(&quot;password&quot;); password.setAccessible(true); password.set(object,&quot;1234567&quot;); print(object.toString()); } 输出 Test{username=&apos;100&apos;, password=&apos;1234567&apos;} 反射方法 public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); method.invoke(object,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 反射 获取方法返回类型public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); Class&lt;?&gt; returnType = method.getReturnType(); int resulr = method.invoke(object,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 result = 2 returnType = int 注意如果反射的方法是静态方法的话可直接invoke(null,…) public static int showInfo(String name,String pwd){ MyClass.print(&quot;name = &quot; + name); MyClass.print(&quot;pwd = &quot; + pwd); return 2; } public static void main(String[] args){ Class&lt;?&gt; cls = Class.forName(&quot;x.com.lib.Test&quot;); Object object = cls.newInstance(); Method method = cls.getDeclaredMethod(&quot;showInfo&quot;,String.class,String.class); Class&lt;?&gt; returnType = method.getReturnType(); int resulr = method.invoke(null,&quot;hello&quot;,&quot;今天天气真好&quot;); } 输出 name = hello pwd = 今天天气真好 result = 2 returnType = int 反射的如果是private属性的一定要注意兼容问题，因为如果别人哪天改了变量名,程序说不定crash了。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石原里美真美]]></title>
    <url>%2F2018%2F04%2F26%2F%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E%E7%9C%9F%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[日剧 非自然死亡看剧过程中随手一截 - -！]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-使用Activity作为Contenxt启动BroadcastReceiveer的一些问题]]></title>
    <url>%2F2018%2F04%2F17%2FAndroid-BroadcastReceiveer%E5%BC%95%E7%94%A8context%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[问题背景下载APK的时候需要做一个通知栏并且支持暂停，取消等功能交互。通知栏的UI点击交互用的就是broadcast来接受点击事件 代码如下 registerReceiver(context, MyBroadcastReceiver); Intent intent = new Intent(ACTION); PendingIntent pendingIntent1 = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); mRemoteViews.setOnClickPendingIntent(mRemoteBuild.clickId, pendingIntent1); 伪代码如上就是为通知栏设置点击事件的一种方法。 可当我测试点击的时候我注册的广播里面就是接收不到点击事件。无奈我有改用静态方式来注册广播，观察log发现静态方式是可以接受到点击事件的那看来就是动态注册方式出了问题。于是我开始整理思路。 打开App，显示开屏广告，点击广告下载apk然后再创建通知栏，再更新下载进度。 而后我继续测试，我将组件拿出来新建了一个项目来测试，发现是正常的，而后再次切换到前者项目测试，发现还是不行接受不到广播点击事件。 我对比发现两者的不同点只是在activity的生命周期上面了。 注意开屏广告的activity生命周期只有3s。这点也非常重要。 附一张非常经典的生命周期图。 而我用新建的项目测试的时候有一点是 当前的activity 在下载过程中一直都没有销毁，而项目里面测试的时候是开屏广告activity，生命周期只有3s，3s之后就已经被自动的finish了。 而又我在新建的项目里面继续写测试代码，写了个3s之后自动finish当前activity，果然也报错了，看来就是跟当前生命周期有关，那也就是传过来的context了。 解决办法想了想，解决办法也很简单。因为下载的service要一直在后台运行，所以将传进来的context.getApplicationContext()，去注册广播，销毁广播等，这样就能保证是在整个app运行期间了，也不会造成内存泄漏问题。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Notification的一些坑。]]></title>
    <url>%2F2018%2F04%2F12%2FAndroid-NotifyManager%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[RemoteViews自定义layout支持大图用setCustomBigContentView方法 123if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; notificationBuilder.setCustomBigContentView(mRemoteViews);&#125; 另外Android 华为7.0默认背景颜色白色，是不会显示任何东西的，不过在小米上面又是正常。另外小米以及华为都是默认都有padding值，注意UI方面调整。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近]]></title>
    <url>%2F2018%2F04%2F11%2F%E6%9C%80%E8%BF%91%2F</url>
    <content type="text"><![CDATA[此时我刚洗完澡，打开花露水抹了抹腿上被蚊子在公司咬的大包。东搞西搞完了之后，打开电脑，时间已经来到11点40了，印象中已经大半年没有加班到这么晚才回家收拾好自己，马上5月了，到了5月来深圳就满整整四个年头了，我眨了眨眼睛,开始发发牢骚。 加班记忆很清晰，刚工作的时候我特别喜欢加班，为何？没钱，住的条件又差，握手楼，屋里没空调，别提多热了，人又比较胖，心想还不如在公司加班，有空调，还能给领导营造出一种你特别努力的工作状态，美哉。 然而实际情况是啥？ 代码写的烂，下什么班啊接着改BUG，由于代码设计不合理，需求频繁变动导致需要推翻之前架构，频繁返工。 既然已经这样了那就干脆更乱一点吧。懒得管了 拿着一个需求直接开始写，不做需求分析。 以上种种情况下还得按时交货，那肯定得加班。 而如今工作已三年有余，生活质量远不像以前那样将就，希望工作之外有较多的私人时间充电,多锻炼,毕竟身体好才是对自己，家人负责。 工作入职了新公司，特别特别小的创业公司，刚好入职的一段时间公司短时间内接了很多项目，服务对方过程中爆发出了一系列问题，老板临时晚上开了个会，会上我表达了一下自己的看法，项目管理上面很乱，很没有章法，服务对象短时间爆发式增长，现有系统架构不稳定，不过想来也是情有可原，毕竟基本都身兼数职，这也就是为什么今天回来的这么晚的原因了。 虽然刚入职不过也算是干了点事，毕竟谁都会背一点技术债，比如以前流程上的不规范，引入新流程，修复潜在漏洞等。 入职不久就启动了一个海外项目，分析完需求之后开始在参考Github上面一些比较出名库的架构，之后用了差不多一周的时间写SDK，基本也是跟自己预估的时间差不多，节奏控制的特别好，基本下班就走。这也是我比较纠结的一个点了，公司基本我走最早，其余都加班，有一个是刚毕业的能力方面可能有所欠缺，加加班也是应该，后来了解到原来其余的都是一起出来创业的 效率加班说明你没有效率 在我看来是这样的，并且非常认同这一句话，如果一天按时完成了工作任务何来加班！ 可是我从创业者角度来看，是这样吗？ 不是 事情做不完。永远做不完 我已入职快一个月了，基本上在coding期间会插进来各种事情，被动的不说，主动方面，由于公司网络库非常老旧，不方便维护，从长远考虑自己写了一个网络库，文档方面又非常散，对外推的时候需要手动给对方，而不是让使用者自主寻找文档，所以自己通过Github pages，找公司要了一个域名，做一个静态网页，管理对外文档，要知道我手上可是有开发任务的，所以比较难专注的去做一件事。 再比如跟我对接的后台，公司基本所有问题都要经他流转，东一下西一下的帮业务处理一些问题，关键还有自己的开发任务。 总之负责的业务越多，精力可能越分散也就无法做好一件事情，出现问题的几率也就越大。 生活关于生活不想说一些生活琐事，而想说说我发生的一些变化。 一个需求动手之前都会想想为何？此事何来？何以见得？ 因为我需要一个合理解释来说服我。 以后再写吧，该睡了 安]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-所谓的动态创建Application的方式]]></title>
    <url>%2F2018%2F04%2F08%2FAndroid%E6%89%80%E8%B0%93%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAApplication%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于需求在不调用代码的情况下，完成SDK初始化以及请求广告开屏广告操作。 拿到这个需求的时候很疑惑，为什么不能调用代码，是考虑到接入我们SDK成本太高？不存在的，SDK的接入都会给使用者详细的文档按照文档接入即可。我提出了我的质疑。甚至觉得这是一个伪需求 然而给我的答案仅仅是优化我们的接入方式。(这就是个伪需求) 怎么做当确定了需求之后我立即着手该怎么而后确定了大致思路 在Manifest里面声明SDK的代理Application累，替换原有的Application，当创建SDK的代理类Application的时候手动初始化我们的SDK，然后使用hook方式启动一个SDK内置WelcomeActivity，请求广告吸附在该WelcomeActivit上面，随后控制其Activity声明周期创建/销毁 关联 广告展示/关闭等周期。 我们知道Android Application 创建的方式即在Manifest里面声明一个name属性即可创建代码如下1234567&lt;application android:name=".sample.MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 对应的继承Application则会被调用。 如果要实现所谓的‘动态替换’Application得从这里入手了。 实现首先在Manifest声明自己的Application类 包名(也就是路径)123&lt;meta-data android:name="APPLICATION_NAME" android:value="com.jadx.android.sample.MyApplication" /&gt; 而后application name属性声明成SDK代理类Application1234567&lt;application android:name=".ProxyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; 在该代理类里面生成真的Application并且实现一系列代理方法核心代码如下 12345678910111213141516171819202122232425262728@Override public void onCreate() &#123; super.onCreate(); mContext = this; final String name = getAppName(); if (!TextUtils.isEmpty(name)) &#123; try &#123; Class clazz = Class.forName(name); mRealApplication = (Application) clazz.newInstance(); mRealApplication.onCreate(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public String getAppName() &#123; try &#123; ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo( mContext.getPackageName(), PackageManager.GET_META_DATA); if (appInfo.metaData != null) &#123; return appInfo.metaData.getString(APP_NAME_KEY); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; return ""; &#125; 当App启动时会走代理类ProxyApplication的OnCreate方法而后通过Class.forName(“包名.类名”)获得其实例，随后代理其一系列原有方法即可。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-OkHttp网络请求的封装]]></title>
    <url>%2F2018%2F04%2F06%2FAndroid-OkHttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Github添加依赖12345678implementation 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'implementation 'com.squareup.okhttp3:okhttp:3.5.0'orcomplie 'com.xingwei:OkHttpUtil-Json:alpha-v0.1.4'compile 'com.squareup.okhttp3:okhttp:3.5.0' Feature 支持JSON解析CallBack声明泛型即可 UI线程回调 支持文件下载 支持Activity/fragment绑定生命周期 支持自定义解析内容 如功能不够，可拿到原生Client，自定义功能 请求Get123456789101112OkHttpRun.get(GET) .execute(new StringCallBack() &#123; @Override public void onSuccess(Call call, String response) &#123; mTextView.setText(response); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); POST12345678910111213OkHttpRun.post(POST).addParams("name", "xwd") .addParams("pwd", "123") .execute(new JsonCallBack&lt;Token&gt;() &#123; @Override public void onSuccess(Call call, Token response) &#123; mTextView.setText(response.toString()); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 下载文件12345678910111213141516171819202122232425String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + "com.test"; OkHttpRun.get("http://download.kugou.com/download/kugou_android") //path 文件路径 // 文件名称 .execute(new FileCallBack&lt;File&gt;(path, "temp.apk") &#123; @Override protected void onProgressListener(float current, long total) &#123; LOG.w("TAG", "current " + current * 100 + "/" + " " + total); &#125; @Override protected void onFinish(File file) &#123; LOG.w("TAG", "finish"); &#125; @Override protected void onStart() &#123; LOG.w("TAG", "start"); &#125; @Override public void onFailure(Call call, Exception e) &#123; &#125; &#125;); 解析默认支持Callback如下 StringCallBack JsonCallBack FileCallBack 如需要其他解析扩展，继承AbstractCallBack 即可比如123456789101112public abstract class StringCallBack extends AbstractCallBack&lt;String&gt; &#123; @Override protected String parser(Call call, Response response) throws IOException &#123; final String result = response.body().string(); onSuccess(call, result); return result; &#125; protected abstract void onSuccess(Call call, String response);&#125; 配置OkHttpClient添加拦截器到默认client123456789101112final Interceptor interceptor = new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; ... return chain.proceed(requestBuilder.build()); &#125; &#125;; //最后build一下 HttpManager.getInstance().addInterceptor(interceptor) .addNetworkInterceptor(); .build(); 获取内置OkHttpClient1HttpManager.getInstance().getDefaultClient(); 设置OKHttpClient1HttpManaget.getInstance().setOkHttpClient();]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-为什么不能再子线程修改UI]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%86%8D%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BF%AE%E6%94%B9UI%2F</url>
    <content type="text"><![CDATA[如果在子线程中修改UI报错如下: 如果问题搞清楚了这三大原则基本上就ok了； why what how Why？ 为什么会报错，报错的方法是checkThread，requestLayout 方法都在ViewRootimpl 类里面, 也就是说一旦ViewRootImpl 这个类被实例化,则就会调用requestLaoyout 方法来检查,requestLayout 方法如下:123456789101112131415@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; void checkThread() &#123; //报错如下 if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125; &#125; 报错的原因是因为咱们没有在主线程里面去修改UI,chechThread 方法会检查当前线程是不是主线程 ##How 正确修改方法如下： 12345678910111213141516171819202122232425262728293031Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //当子线程获取到数据之后使用Handler 来修改UI // 当然如果这样写会存在内存泄露 这里不做讨论 if(msg.waht == 0x123)&#123; textView.setText("主线程修改UI"); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.supportRequestWindowFeature(Window.FEATURE_ACTION_BAR); setContentView(R.layout.aty_xxx); new Thread(new Runnable() &#123; @Override public void run() &#123; //获取数据 //成功之后使用handler 发送what Message msg = Message.obtain(); msg.what = 0x123; msg.obj = datas; hanlder.sendMessage(msg) &#125; &#125;).start(); &#125; 以上就是在主线程修改UI的标准写法。 What请观察以下代码1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.supportRequestWindowFeature(Window.FEATURE_ACTION_BAR); setContentView(R.layout.aty_xxx); new Thread(new Runnable() &#123; @Override public void run() &#123; textView.setText("我在onCreate方法 一开始的时候就修改UI你拿我怎的?"); &#125; &#125;).start(); &#125;&#125; 以上代码会不会执行成功呢？如果你是从文章的开始看到这里来的话也许您会说肯定不能运行啊，不能再子线程里面修改UI啊；很遗憾，程序会正常运行，（截图我就不上了，有兴趣探究的同学可以试试）而模拟器上也会显示textView 几个大字；那到底这是为什么呢？ 这里我们回到之前的为什么会报错，咱们进入源码看一看：、123456789101112131415@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; void checkThread() &#123; //报错如下 if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125; &#125; 前面说到了如果实例化了ViewRootImpl 这个类则会检查当前线程是不是主线程，那么直接杀到在哪里实例化ViewRootImpl 这个类的地方不就水落石出了嘛，别急,咱们一步一步来:可以看到requestLayout 调用了checkThread ，和scheduleTraversals（） 方法，前者呢 是抛出错误的地方那后者呢？123456789void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); // 省略 &#125; &#125; 这里postCallback 方法 第一个为一个常数，第三个是null，第二个则是一跟线程，代码如下；123456789101112131415161718192021222324final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing("ViewAncestor"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; performTraversals() 这个方法则是View进行绘制的开始； 每一次访问UI，即UI则会重绘； 回过头来我们再来找找在哪里进行实例化 ViewRootimpl 的；12345678910111213141516171819 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration // 执行resume activity ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, "Resume " + r + " started activity: " + a.mStartedActivity + ", hideForNow: " + r.hideForNow + ", finished: " + a.mFinished);&#125; 可以看到上面执行了resumeActivity 方法 ； 方法如下：1234567891011121314public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) &#123; ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, "Performing resume of " + r + " finished=" + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) &#123; if (clearHide) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; // 省略 r.activity.performResume(); //省略&#125; 这里可以看到回调了activity.performResume() 方法 方法如下: Activity ===&gt;performResume()1234567891011121314151617 final void performResume() &#123; performRestart(); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; mCalled = false; // mResumed is set by the instrumentation mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; throw new SuperNotCalledException( "Activity " + mComponent.toShortString() + " did not call through to super.onResume()"); &#125;&#125; mInstrumentation 是用来辅助Activity完成启动Activity的过程 Instrumentation===&gt;callActivityOnResume()1234567891011121314public void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); &#125; &#125; &#125; &#125; 可是看到真正执行onResume在这里 也就是说执行到这里 activity 的生命周期经历如下onCreate —– onStart ——onResume; 而performResumeActivity 里面执行完回调activity.onResume() 方法 有如下代码:12345r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; 进入makeVisible 如下: Activity===&gt;callActivityOnResume()12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE); &#125; ViewManager 是一个抽象类，而mDecor 是一个View ，我们找到ViewManager 实现类如下: WindowManagerGlobal===&gt;addView()123456789101112131415161718192021222324252627282930public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (display == null) &#123; throw new IllegalArgumentException("display must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; //省略 ViewRootImpl root; View panelParentView = null; //省略 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; //省略 &#125; 进入到addView 方法内部终于找到了实例化ViewRootImpl 的地方; 这也就是解释了为什么在oncreate 生命周期刚开始的时候在子线程修改UI会报错呢，因此此时的ViewRootImpl 还没有被实例化； 1ActivityClientRecord r = performResumeActivity(token, clearHide); 要知道ViewRootImpl 实例化是在执行完handleResumeActivity 方法里面以上代码之后哦，而performResumeActivity 是回调activity.onResume的，他们的流程是这样的 可是ViewRootImpl 实例化最后的过程是在activity -&gt; makeVisible 方法里面在里面调用了在WindowManagerGlobal （ViewManager 的实现类）—&gt;addView 真正实行了ViewRootImpl 的实例化 有时候看源码真的很枯燥，但是某一个把自己看过的源码给串起来的感觉真的特别好（比如笔者之后有了解了activity的启动过程）; 参考文章:http://blog.csdn.net/xyh269/article/details/52728861http://blog.csdn.net/singwhatiwanna/article/details/18154335]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 工厂方法模式]]></title>
    <url>%2F2018%2F03%2F03%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪个类 而工厂方法模式有一套通用模式代码 定义zoo类如下: 1234public abstract class Zoo &#123; public abstract void showAnimal();&#125; dog类如下: 1234567public class Dog extends Zoo &#123; @Override public void showAnimal() &#123; System.out.println("dog is show"); &#125;&#125; pig类如下: 123456public class Pig extends Zoo &#123; @Override public void showAnimal() &#123; System.out.println("pig is show"); &#125;&#125; 定义一个工厂方法接口: 1234public interface Factory &#123; Zoo createAnimal();&#125; 实现类: 1234567public class ClientFactory implements Factory &#123; @Override public Zoo createAnimal() &#123; return new Dog(); //return new Pig(); &#125;&#125; 123456public static void main(String[] arg)&#123; Factory factory = new ClientFactory(); Dog zoo = (Dog) factory.createAnimal(); // or Pig pig = (Pig) factory.createAnimal(); zoo.showAnimal();&#125; 输出结果 1dog is show 需要哪一个类的对象就传入哪一个类的类型即可，这种方法比较简洁，动态。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 代理模式]]></title>
    <url>%2F2018%2F02%2F27%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为其他对象提供一种代理一控制对这个对象的访问。 场景当不想直接访问某个对象或访问某个对象存在着一定困难时就可以通过一个代理对象来间接访问。 Code1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String args[]) &#123; // 通过代理类访问具体执行发送信息对象 ProxyMessage proxy = new ProxyMessage(); proxy.sendMessage("Android"); &#125; //代理类 static class ProxyMessage &#123; final Message mMessage = new Message(); void sendMessage(String type) &#123; if ("Android".equals(type)) &#123; mMessage.sendAndroid(); &#125; else &#123; mMessage.sendIOS(); &#125; &#125; &#125; public static class Message &#123; void sendAndroid() &#123; System.out.println("send Android"); &#125; void sendIOS() &#123; System.out.println("send ios"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-关于LayoutInflater加载布局导致布局宽高失效]]></title>
    <url>%2F2018%2F02%2F26%2FAndroid%E5%85%B3%E4%BA%8ELayoutInflater%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80%E5%AF%BC%E8%87%B4%E5%B8%83%E5%B1%80%E5%AE%BD%E9%AB%98%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[为何宽高失效？想要实现如下效果只需要一个recyclerView里面一个textView即可。 Adapter 代码 123456789101112131415161718192021222324252627282930313233343536373839static class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mStrings = new ArrayList&lt;&gt;(); public MyAdapter(Context context) &#123; mContext = context; for (int i = 0; i &lt; 20; i++) &#123; mStrings.add("" + i); &#125; &#125; @Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); return new MyHolder(view); &#125; @Override public void onBindViewHolder(MyHolder holder, int position) &#123; holder.mTextView.setText(mStrings.get(position)); &#125; @Override public int getItemCount() &#123; return mStrings.size(); &#125; static class MyHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyHolder(View itemView) &#123; super(itemView); mTextView = itemView.findViewById(R.id.text); &#125; &#125; &#125; xml文件如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/black" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:padding="12dp" android:layout_height="wrap_content" android:textColor="@android:color/white" android:gravity="center" android:text="123123"/&gt; &lt;/LinearLayout&gt; 可是实现的效果是这样的 可以看到宽明明是match _ parent但是在这里却变成了wrap_content,即文本长度多长，textView宽度都宽，为什么会失效呢？ 首先一个View的宽高padding什么的失我第一个想到的就是LayoutParams，因为一些xml里面属性都在LayoutParams里面，如果失效了估计是LayoutParams没有set上去。 关于LayoutInflater123LayoutInflater.from(mContext).inflate(R.layout.item_list, null);LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 以上是最为普通使用LayoutInflater加载Layout方式，上面的列子中如果使用了3个参数的方法来加载Layout，也就解决了宽度问题，搞懂了2个参数和3个参数方法的区别也就明白了。 代码如下 12345@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, parent, false); return new MyHolder(view); &#125; 如上也就解决了宽度失效问题，可是为什么呢？ 源码 1234567891011121314/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy. * @return The root View of the inflated hierarchy. If root was supplied, * this is the root View; otherwise it is the root of the inflated * XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; 本质上2个参数的方法也是调用了3个参数的方法。三个参数源码如下 1234567891011121314151617181920212223242526272829303132/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; //解析xml final XmlResourceParser parser = res.getLayout(resource); try &#123; //inflate的地方 return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; * &lt;em&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;For performance * reasons, view inflation relies heavily on pre-processing of XML files * that is done at build time. Therefore, it is not currently possible to * use LayoutInflater with an XmlPullParser over a plain XML file at runtime. * * @param parser XML dom node containing the description of the view * hierarchy. * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... 省略部分代码 if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; // 判断是否是merge标签 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); // 关键点 ViewGroup.LayoutParams params = null; // parent 是否为空 if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied // 创建跟布局的LayoutParams params = root.generateLayoutParams(attrs); // 是否为false 如果是flase则添加到view里面 if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. // 注意到这里如果是true 则会将其View添加到root里面 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ... 省略部分代码 return result; &#125; &#125; 注意看到判断是否MERGE的else分支，里面关键的地方都已经写上注释。 其实也就是说，如果root不是空的话，回去创建LayoutParams，在判断如果attchToRoot参数如果是false，则会setLayoutParams到View里面去。 文章的开头有说到LayoutParams这个类，里面都是一个在xml声明的属性，那我们尝试的从侧门解决一下问题，看如下代码 123456@Override public MyHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_list, null); view.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); return new MyHolder(view); &#125; 我手动为其设置了LayoutParams，结果如何呢？如下 一样的。 为什么失效之后又是wrap_content呢？这是因为RecyclerView里面机制如果LayoutParams是空的会给一个默认的LayoutParams。以后有兴趣贴源码。 总结12345// 只会生成View 并不会设置任何属性LayoutInflater.from(mContext).inflate(R.layout.item_list, null);// 如果parent不为空会为其生成LayoutParams属性，// attchToRoot如果为flase则会将LayoutParams Set进去，如果为true，则会添加到root里面LayoutInflater.from(mContext).inflate(R.layout.item_list,parent, false); 分割线这种问题其实在开发中非常常见不过当时解决了之后并没有深究其原因实属不该。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式 Builder模式]]></title>
    <url>%2F2018%2F02%2F25%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍Builder模式是一步一步创建一个复杂对象的创建型模式，可以更精细的控制对象的构造流程。 使用场景 当初始化一个对象特别复杂，比如说参数多，且很多参数都具有默认值 多个部件或者零件，都可以组装到同一个对象中，但是产生的运行结果又不相同。 实现12345678910111213141516171819202122232425262728293031323334public static class Builder &#123; private ViewStub mEmptyViewStub; private ViewStub mLoadingViewStub; private ViewStub mFailureViewStub; private Context mContext; public Builder(Context context) &#123; mContext = context; &#125; public Builder setEmptyViewId(@LayoutRes int resId) &#123; mEmptyViewStub = new ViewStub(mContext); mEmptyViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingLayoutId(@LayoutRes int resId) &#123; mLoadingViewStub = new ViewStub(mContext); mLoadingViewStub.setLayoutResource(resId); return this; &#125; public Builder setLoadingFailureId(@LayoutRes int resId) &#123; mFailureViewStub = new ViewStub(mContext); mFailureViewStub.setLayoutResource(resId); return this; &#125; public XwStateLayoutManager build() &#123; return new XwStateLayoutManager(this); &#125; &#125; 以上代码是构建通用布局所需要的零件，所以采用了Builder模式来构建所需要的零件 Android 源码实现可参考AlertDialog.Builder 实现。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxAndroid 常用操作符记录]]></title>
    <url>%2F2018%2F01%2F26%2FRxAndroid-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[map,filter,操作符区别？12345678910111213141516171819202122232425//mapObservable.just(mIntegers). map(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; list) &#123; // 做想做的操作 int number = list.get(i); return nulber == 2; &#125; &#125;).subscribe(new Observer&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Boolean aBoolean) &#123; Log.d("TAG", "A = " + aBoolean); &#125; &#125;); 1234567891011121314151617181920212223//filter Observable.just(mIntegers).filter(new Func1&lt;List&lt;Integer&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;Integer&gt; integers) &#123; final int b = integers.get(3); return b &gt; 10; &#125; &#125;).subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; print("size = " + integers.size()); &#125; &#125;); 注意以上代码结果，无论map操作符结果是ture，还是false，订阅者observer都会收到方法回调。 而filter不一样，如果不满足条件observer是不会收到方法回调。 flatMap1234567891011121314151617181920212223242526Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); flatMap 操作符实际上是一个一对多的转换，结合如上业务代码很好理解 根据token去获取到所有的用户信息，查询大于15岁的的用户信息，最后返回一个用户信息集合给订阅者。 flatMap 会返回一个Obervable流，而不像map操作符返回的是一对一的结果。 线程调度在如上列子中，是一个同步任务列子，如何制定为异步任务的话很可能会导致卡顿，那么这里就需要使用大Rx非常强大的线程调度,并且特别方便。先看如下代码 12345678910111213141516171819202122232425262728Observable.just(token).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; for（User user : users）&#123; if(user.age &gt; 15)&#123; return userHelper.getUserInfo(); &#125;else&#123; return null; &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; &#125; &#125;); 注意两个概念 subscribeOn : 指定其事件产生线程 observeOn : 指定事件消费线程 12.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) 如上两句代码则完成线程的切换工作。 如果存在多个observable事件源如何切换线程?12345678910111213141516171819202122232425262728293031Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); // 省略判断条件 return Observale.just(mGirls).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;User&gt; users) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); 如上代码subscribeOn调用了2次flatMap流指定生产线程为异步线程，而filter流指定了生产线程为主线程最后看一下输出结果： 123com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次. 注意： subscribeOn的调用切换之前的线程。 observeOn的调用切换之后的线程。 observeOn之后，不可再调用subscribeOn 切换线程 看如下代码log如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.just(mUsers).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;List&lt;User&gt;&gt;&gt;() &#123; @Override public Observable&lt;List&lt;User&gt;&gt; call(List&lt;User&gt; users) &#123; print("1 = " + (Looper.getMainLooper() == Looper.myLooper())); return Observable.just(users).filter(new Func1&lt;List&lt;User&gt;, Boolean&gt;() &#123; @Override public Boolean call(List&lt;User&gt; users) &#123; print("2 = " + (Looper.getMainLooper() == Looper.myLooper())); return true; &#125; &#125;).subscribeOn(AndroidSchedulers.mainThread()).observeOn(Schedulers.io()); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(new Func1&lt;List&lt;User&gt;, String&gt;() &#123; @Override public String call(List&lt;User&gt; users) &#123; print("3 = " + (Looper.getMainLooper() == Looper.myLooper())); return "1"; &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; print("end = " + (Looper.getMainLooper() == Looper.myLooper())); &#125; &#125;); com.example.huangxingwei.rxandroidsimple D/TAG: 1 = falsecom.example.huangxingwei.rxandroidsimple D/TAG: 2 = truecom.example.huangxingwei.rxandroidsimple D/TAG: 3 = truecom.example.huangxingwei.rxandroidsimple D/TAG: end = true 即使在最后一个map指定subscribeOn线程为IO，打印出来还是在主线程。observeOn之后再次调用 subscribeOn是无效的参考文章 http://blog.csdn.net/jdsjlzx/article/details/51685769]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-带三角形箭头头的指引TipLayout实现]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid%E5%B8%A6%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%8C%87%E5%BC%95tipLayout%E5%AE%9E%E7%8E%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[如上设计图，要求三角形指示器需要动态对齐上面的文本，需要动态的实现对其三角形。 引用方式123compile 'com.xiaowei:TriangleTipLayout:1.0.1'//orimplementation 'com.xiaowei:TriangleTipLayout:1.0.1' 实现思路准备一个三角形指引的图片即可。先上代码 12345678910111213141516171819202122232425262728final TextPaint textPaint = mTextView.getPaint(); final int textHeight = (int) (textPaint.descent() - textPaint.ascent()); mRect.set(0, DEFAULT_TOP_HEIGHT, getWidth(), getHeight() + textHeight - DEFAULT_TOP_HEIGHT); canvas.drawRect(mRect, mRectPaint); final String text = mTextView.getText().toString(); float left = 0; if (mIsShowTriangle) &#123; if (mGravity == Gravity.LEFT || mGravity == Gravity.START) &#123; LayoutParams layoutParams = (LayoutParams) mTarget.getLayoutParams(); left = mTarget.getLeft() - layoutParams.rightMargin - layoutParams.leftMargin; &#125; else &#123; if (mTarget instanceof TextView) &#123; ViewParent viewParent = mTarget.getParent(); float textWidth = textPaint.measureText(text); if (viewParent instanceof LinearLayout) &#123; final float width = mTarget.getWidth() / 2; left = mTarget.getLeft() + width - (mBitmap.getWidth() / 2); &#125; else if (viewParent instanceof RelativeLayout) &#123; left = mTarget.getLeft() + textWidth / 2; &#125; &#125; else if (mTarget instanceof ImageView) &#123; final float width = mTarget.getWidth(); left = mTarget.getLeft() + (width / 2) - (mBitmap.getWidth() / 2); &#125; &#125; canvas.drawBitmap(mBitmap, left, 0, mBitmapPaint); &#125; &#125; 核心代码如上,其思路是先绘制一个矩形，预留出三角形指示器图片所需要的高度，最后将其三行图片绘制出来。 配置指示器123456mTipsLayout.setRectBackgroundColor(Color.parseColor("#FFF8BE"));mTipsLayout.setTextColor(Color.parseColor("#FF9B33"));mTipsLayout.setTriangleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_triangle_arrow));mTipsLayout.setTriangleGravity(Gravity.START);mTipsLayout.bindView(findViewById(R.id.text2));mTipsLayout.setText("您今日收入已到达10W+，牛逼。保持努力"); 注意：当调用setText之后会invalidate()重新绘制; 实现效果如下: Feature todo About GitHub:Github/xwdz/TriangleTipLayout]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio发布个人开源项目至bintray]]></title>
    <url>%2F2017%2F11%2F12%2FAndroidStudio%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91bintray%2F</url>
    <content type="text"><![CDATA[创建账号创建账号时要注意要用国外邮箱。 使用插件发布 项目根目录 build.gradle 添加引用 1classpath 'com.novoda:bintray-release:0.3.4' library目录下的build.gradle 配置如下信息 1234567891011121314151617181920apply plugin: 'com.android.library'//添加如下引用apply plugin: 'com.novoda.bintray-release'//def siteUrl = 'https://github.com/xwdz/BarChartView'publish &#123; userOrg = 'quinnhuang'//bintray.com的用户名 repoName = 'xw-widget'//远程仓库名字,不指明，默认是上传到maven groupId = 'com.xiaowei'//jcenter上的路径 artifactId = 'barchart-view'//项目名称 publishVersion = '1.0.0'//版本号 desc = '轻量型柱形图'//描述，不重要 website = siteUrl//项目主页&#125;tasks.withType(Javadoc) &#123;//防止编码问题 options.addStringOption('Xdoclint:none', '-quiet') options.addStringOption('encoding', 'UTF-8') options.addStringOption('charSet', 'UTF-8')&#125; 上传至bintray1./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxxx -PdryRun=falser 期间遇到的问题用户名不统一1Could not create version '1.0.0': HTTP/1.1 401 Unauthorized PbintrayUser、userOrg 两者属性属性必须一样，即bintray.com的用户名 lint 检查出来的错误12345android &#123; lintOptions &#123; abortOnError false &#125; &#125; 在你library以及App的build.gradle的androud模块添加 123456789101112131415161718192021222324android &#123; compileSdkVersion 26 buildToolsVersion "26.0.0" defaultConfig &#123; minSdkVersion 21 targetSdkVersion 26 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; // 忽略lint lintOptions &#123; abortOnError false &#125;&#125; 最后add central 等待审核即可]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio-点9图]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-studio-9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[生成.9图Android Studio 对于.9图的生成也非常友好，直接点击图片右建create.9图； 图片右键 =&gt; Create 9-patch File =&gt; 确定即可，生成.9图之后打开即如见下图 文件名会默认为：xxx.9.png 如上图4条黑线位置构成拉伸区域]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-混淆相关]]></title>
    <url>%2F2017%2F10%2F03%2FAndroid-%E6%B7%B7%E6%B7%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[忽略tmp.txt tmp.txt 忽略所有log文件 .log 忽略tmp文件夹所有文件 tmp/* 忽略log目录下的包括子目录下的所有log文件 log/**/*.log 查看项目ＳＨＡ１ ＭＤ５ 值 keytool -v -list -keystore ~/.android/debug.keystore]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令记录]]></title>
    <url>%2F2017%2F10%2F03%2Fgit%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[删除本地分支 git branch -d 分支名 删除未合并分支 git branch -D 分支名 新建本地分支 git branch 分支名 推送分支到服务器 git push origin 本地分支名:服务器分支名 删除远程分支 git push origin --delete &lt;branchName&gt; git 回退commit首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本. 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 $ git reset --hard HEAD^ 版本比对git diff commitMD5 git工作流当release分支结束时，使用gitflow，finish掉分支 git flow release finish &#39;1.1&#39;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
